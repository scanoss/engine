// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * src/vulnerability.c
 *
 * "Vulnerability" data aggregation functions
 *
 * Copyright (C) 2018-2021 SCANOSS.COM
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "vulnerability.h"
#include "limits.h"
#include "parse.h"
#include "debug.h"
#include "util.h"
#include "decrypt.h"

const char *vulnerability_sources[] = {"nvd", "github_advisories"};

/* Returns true if versions are equal (or if one version starts with the other version) */
static bool version_equal(char *v1, char *v2)
{
	if (!*v1 || !*v2) return false;
	while (*v1 && *v2) if (*(v1++) != (*(v2++))) return false;
	return true;
}

/* Returns true if version1 fulfills version2 condition */
static bool version_condition(char *version1, char *version2)
{
	if (!*version2) return true;
	if (!memcmp(version2, ">=", 2)) return (strcmp(version1, version2 + 2) >= 0);
	if (!memcmp(version2, "<=", 2)) return (strcmp(version1, version2 + 2) <= 0);
	if (*version2 == '>') return (strcmp(version1, version2 + 1) > 0);
	if (*version2 == '<') return (strcmp(version1, version2 + 1) < 0);
	if (*version2 == '=') return (strcmp(version1, version2 + 1) == 0);

	return version_equal(version1, version2);
}
		
static bool vulnerability_version_matches(match_data *match, int src, char *introduced, char *patched)
{

	/* NVD vulnerabilities must match version */
	if (src == 0)
	{
		if (version_equal(match->version, introduced)) return true;
		if (version_equal(match->latest_version, introduced)) return true;
		if (version_equal(match->version, patched)) return true;
		if (version_equal(match->latest_version, patched)) return true;
		return false;
	}

	/* Test version against affected range */
	if (version_condition(match->version, introduced))
		if (version_condition(match->version, patched)) return true;

	/* Test latest version against affected range */
	if (version_condition(match->latest_version, introduced))
		if (version_condition(match->latest_version, patched)) return true;

	return false;
}

static bool print_vulnerability_item(uint8_t *key, uint8_t *subkey, int subkey_ln, uint8_t *data, uint32_t datalen, int iteration, void *ptr)
{
	match_data *match = ptr;

	/* Set a limit to the amount of vulnerabilities returned */
	if (match->vulnerabilities > max_vulnerabilities) return true;

	decrypt_data(data, datalen, "vulnerability", key, subkey);

	char *CSV = calloc(datalen + 1, 1);
	memcpy(CSV, (char *) data, datalen);
	
	char *source = calloc(MAX_JSON_VALUE_LEN, 1);
	char *introduced = calloc(MAX_JSON_VALUE_LEN, 1);
	char *patched = calloc(MAX_JSON_VALUE_LEN, 1);
	char *CVE  = calloc(MAX_JSON_VALUE_LEN, 1);
	char *ID  = calloc(MAX_JSON_VALUE_LEN, 1);
	char *severity = calloc(MAX_JSON_VALUE_LEN, 1);
	char *date = calloc(MAX_JSON_VALUE_LEN, 1);
	char *summary = calloc(MAX_JSON_VALUE_LEN, 1);

	extract_csv(source, CSV, 1, MAX_JSON_VALUE_LEN);
	extract_csv(introduced, CSV, 3, MAX_JSON_VALUE_LEN);
	extract_csv(patched, CSV, 4, MAX_JSON_VALUE_LEN);
	extract_csv(CVE, CSV, 5, MAX_JSON_VALUE_LEN);
	extract_csv(ID, CSV, 6, MAX_JSON_VALUE_LEN);
	extract_csv(severity, CSV, 7, MAX_JSON_VALUE_LEN);
	extract_csv(date, CSV, 8, MAX_JSON_VALUE_LEN);
	extract_csv(summary, CSV, 9, MAX_JSON_VALUE_LEN);

	string_clean(introduced);
	string_clean(patched);
	string_clean(CVE);
	string_clean(ID);
	string_clean(severity);
	string_clean(date);
	string_clean(summary);

	remove_char(introduced, ' ');
	remove_char(patched, ' ');

	free(CSV);

	int src = atoi(source);

	if (*ID && (src < (sizeof(vulnerability_sources) / sizeof(vulnerability_sources[0]))))
	{
		if (vulnerability_version_matches(match, src, introduced, patched))
		{
			/* Calculate CRC to avoid duplicates */
			uint32_t CRC = string_crc32c(source) + string_crc32c(summary);
			if (!add_CRC(match->crclist, CRC))
			{
				if (match->vulnerabilities) printf(",\n"); else printf("\n");
				printf("        {\n");
				printf("          \"ID\": \"%s\",\n", ID);
				printf("          \"CVE\": \"%s\",\n", CVE);
				printf("          \"severity\": \"%s\",\n", severity);
				printf("          \"reported\": \"%s\",\n", date);
				printf("          \"introduced\": \"%s\",\n", introduced);
				printf("          \"patched\": \"%s\",\n", patched);
				printf("          \"summary\": \"%s\",\n", summary);
				printf("          \"source\": \"%s\"\n", vulnerability_sources[src]);
				printf("        }");
				match->vulnerabilities++;
			}
		}
	}

	free(source);
	free(introduced);
	free(patched);
	free(CVE);
	free(ID);
	free(severity);
	free(date);
	free(summary);

	return false;
}

/* Calculate the hash of vendor/component/version */
void version_md5(uint8_t *out, char *vendor, char *component, char *version)
{
	char triplet[MAX_ARGLN];
	sprintf(triplet, "%s/%s/%s", vendor, component, version);
	MD5((uint8_t *)triplet, strlen(triplet), out);
}

/* Calculate the hash of purl@version */
void purl_version_md5(uint8_t *out, char *purl, char *version)
{
	char purl_version[MAX_ARGLN];
	sprintf(purl_version, "%s@%s", purl, version);
	MD5((uint8_t *)purl_version, strlen(purl_version), out);
}

void print_vulnerabilities(match_data match)
{
	printf("[");

	/* Clean crc list (used to avoid duplicates) */
	for (int i = 0; i < CRC_LIST_LEN; i++) match.crclist[i] = 0;

	match.vulnerabilities = 0;

	/* Search for purl */
	if (!match.vulnerabilities)
	{
		for (int i = 0; i < MAX_PURLS && *match.purl[i]; i++)
			ldb_fetch_recordset(NULL, oss_vulnerability, match.purl_md5[i], false, print_vulnerability_item, &match);
	}

	/* Search for purl@version in NVD */
	if (!match.vulnerabilities)
	{
		for (int i = 0; i < MAX_PURLS && *match.purl[i]; i++)
		{
			uint8_t md5[MD5_LEN];
			purl_version_md5(md5, match.purl[i], match.version);
			ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, &match);
		}
	}

	/* Search for for purl@latest_version in NVD */
	if (!match.vulnerabilities && strcmp(match.version, match.latest_version))
	{
		for (int i = 0; i < MAX_PURLS && *match.purl[i]; i++)
		{
			uint8_t md5[MD5_LEN];
			purl_version_md5(md5, match.purl[i], match.latest_version);
			ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, &match);
		}
	}

	/* Search for vendor/component */
	if (!match.vulnerabilities)
		ldb_fetch_recordset(NULL, oss_vulnerability, match.pair_md5, false, print_vulnerability_item, &match);

	/* Search for vendor/component/version in NVD */
	if (!match.vulnerabilities)
	{
		uint8_t md5[MD5_LEN];
		version_md5(md5, match.vendor, match.component, match.version);
		ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, &match);
	}

	/* Search for vendor/component/latest_version in NVD */
	if (!match.vulnerabilities && strcmp(match.version, match.latest_version))
	{
		uint8_t md5[MD5_LEN];
		version_md5(md5, match.vendor, match.component, match.latest_version);
		ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, &match);
	}

	if (match.vulnerabilities) printf("\n      ");
	printf("],\n");
}


