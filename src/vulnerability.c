// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * src/vulnerability.c
 *
 * "Vulnerability" data aggregation functions
 *
 * Copyright (C) 2018-2021 SCANOSS.COM
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/**
  @file vulnerability.c
  @date 27 Nov 2020
  @brief Contains the functions used for process the match vulnerabilities.
 
  Long description // TODO
  @see https://github.com/scanoss/engine/blob/master/src/vulnerability.c
 */

#include "debug.h"
#include "decrypt.h"
#include "limits.h"
#include "parse.h"
#include "query.h"
#include "util.h"
#include "vulnerability.h"
#include "semver.h"
#include "versions.h"
/** @brief //TODO */
const char *vulnerability_sources[] = {"nvd", "github_advisories"};

	
/**
 * @brief Vulnerability version analizys for a match
 * @param match pointer to match struct
 * @param introduced First version since Vulnerability was detected
 * @param patched Last version that contains the Vulnerability
 * @return 1 if the matched version is the vulnerable range, 0 other cases
 */
static bool vulnerability_version_matches(char * version, char *introduced, char *patched)
{ 
	semver_t semver_current = {};
	semver_t semver_introduced = {};
	semver_t semver_patched = {};
	char op1[]="   ";
	char op2[]="   ";

	semver_parse(version, &semver_current);

	/* Get operators for introduced and patched, that could be:
	Introduced: "", >, =, >=
	Patched: "",=,<,<= 
	*/
	if (!memcmp(introduced, ">=", 2)) 
	{ 
		semver_parse(introduced+2, &semver_introduced);
		sprintf(op1,">=");
	} 
		else 
			if (!memcmp(introduced, ">", 1)) 
			{ 
				semver_parse(introduced+1, &semver_introduced);
				sprintf(op1,">");
			} 
			else 
				if (!memcmp(introduced, "=", 1)) 
				{
					semver_parse(introduced+1, &semver_introduced);
					sprintf(op1,"=");
				} else 
					if (introduced[0]==' ') 
					{
						semver_parse("", &semver_introduced);
						sprintf(op1," ");
					}

	if (!memcmp(patched, "<=", 2)) 
	{
		semver_parse(patched+2, &semver_patched);
		sprintf(op2,"<=");
	} 
	else 
		if (!memcmp(patched, "<", 1)) 
		{ 
			semver_parse(patched+1, &semver_patched);
			sprintf(op2,"<");
		} 
		else 
			if (!memcmp(patched, "=", 1)) 
			{
				semver_parse(patched+1, &semver_patched);
				sprintf(op2,"=");
			} 
			else
				if (!memcmp(patched, " ", 1)) 
				{
					semver_parse("", &semver_patched);
					sprintf(op2," ");
				}

	/*Case0 op1 - op2*/
	if (op1[0]!=' ' && op2[0]!=' ') 
	{
		return semver_satisfies(semver_current,semver_introduced, op1)&&(semver_satisfies(semver_current,semver_patched, op2));
	} 
	/*Case1 "" - op2*/
	if (op1[0]==' ' && op2[0]!=' ')
	{
		return (semver_satisfies(semver_current,semver_patched, op2)) ;
	} 
	/*Case2 op1 - ""*/
	if(op1[0]!=' ' && op2[0]==' ')
	{
		return semver_satisfies(semver_current,semver_introduced, op1);
	} 
	
	return false;
}

/**
 * @brief Print a vulneraility item in STDOUT-
 * Will be executed for the ldb_fetch_recordset function in each iteration. See LDB documentation for more details.
 * @param key //TODO
 * @param subkey //TODO
 * @param subkey_ln //TODO
 * @param data //TODO
 * @param datalen //TODO
 * @param iteration //TODO
 * @param ptr //TODO
 * @return //TODO
 */
static bool print_vulnerability_item(uint8_t *key, uint8_t *subkey, int subkey_ln, uint8_t *data, uint32_t datalen, int iteration, void *ptr)
{
	component_data_t *comp = ptr;

	/* Set a limit to the amount of vulnerabilities returned */
	if (comp->vulnerabilities > max_vulnerabilities) return true;

	char * CSV = decrypt_data(data, datalen, oss_vulnerability, key, subkey);

	if (!CSV)
		return false;
	
	char *source = calloc(MAX_JSON_VALUE_LEN, 1);
	char *introduced = calloc(MAX_JSON_VALUE_LEN, 1);
	char *patched = calloc(MAX_JSON_VALUE_LEN, 1);
	char *CVE  = calloc(MAX_JSON_VALUE_LEN, 1);
	char *ID  = calloc(MAX_JSON_VALUE_LEN, 1);
	char *severity = calloc(MAX_JSON_VALUE_LEN, 1);
	char *date = calloc(MAX_JSON_VALUE_LEN, 1);
	char *summary = calloc(MAX_JSON_VALUE_LEN, 1);

	extract_csv(source, CSV, 1, MAX_JSON_VALUE_LEN);
	extract_csv(introduced, CSV, 3, MAX_JSON_VALUE_LEN);
	extract_csv(patched, CSV, 4, MAX_JSON_VALUE_LEN);
	extract_csv(CVE, CSV, 5, MAX_JSON_VALUE_LEN);
	extract_csv(ID, CSV, 6, MAX_JSON_VALUE_LEN);
	extract_csv(severity, CSV, 7, MAX_JSON_VALUE_LEN);
	extract_csv(date, CSV, 8, MAX_JSON_VALUE_LEN);
	extract_csv(summary, CSV, 9, MAX_JSON_VALUE_LEN);

	string_clean(introduced);
	string_clean(patched);
	string_clean(CVE);
	string_clean(ID);
	string_clean(severity);
	string_clean(date);
	string_clean(summary);

	remove_char(introduced, ' ');
	remove_char(patched, ' ');

	free(CSV);

	int src = atoi(source);

	if (*ID && (src < (sizeof(vulnerability_sources) / sizeof(vulnerability_sources[0]))))
	{
		char result [MAX_FIELD_LN] = "\0";
		int len = 0;
		if (vulnerability_version_matches(comp->version, introduced, patched) || *source == '0')
		{
			/* Calculate CRC to avoid duplicates */
			uint32_t CRC = string_crc32c(source) + string_crc32c(ID) +  string_crc32c(CVE);
			if (!add_CRC(comp->crclist, CRC))
			{
				if (comp->vulnerabilities)
					len += sprintf(result+len,",");
				len += sprintf(result+len,"{");
				len += sprintf(result+len,"\"ID\": \"%s\",", ID);
				len += sprintf(result+len,"\"CVE\": \"%s\",", CVE);
				len += sprintf(result+len,"\"severity\": \"%s\",", severity);
				len += sprintf(result+len,"\"reported\": \"%s\",", date);
				len += sprintf(result+len,"\"introduced\": \"%s\",", introduced);
				len += sprintf(result+len,"\"patched\": \"%s\",", patched);
				len += sprintf(result+len,"\"summary\": \"%s\",", summary);
				len += sprintf(result+len,"\"source\": \"%s\"", vulnerability_sources[src]);
				len += sprintf(result+len,"}");

				str_cat_realloc(&comp->vulnerabilities_text, result);
				comp->vulnerabilities++;
			}
			else
			scanlog("Vulnerability rejected by CRC: %s\n",ID);
		}
		else
			scanlog("Vulnerability rejected by version: %s\n",ID);
	}
	else
		scanlog("Vulnerability skipped: %s\n",ID);

	free(source);
	free(introduced);
	free(patched);
	free(CVE);
	free(ID);
	free(severity);
	free(date);
	free(summary);

	return false;
}

/**
 * @brief Calculate the hash of vendor/component/version
 * @param out[out] calculated hash
 * @param vendor vendor input string
 * @param component component input string
 * @param version version input string
 */
void version_md5(uint8_t *out, char *vendor, char *component, char *version)
{
	char triplet[strlen(vendor) + strlen(version) + strlen(component) + 10];
	sprintf(triplet, "%s/%s/%s", vendor, component, version);
	MD5((uint8_t *)triplet, strlen(triplet), out);
}

/**
 * @brief print vulnerabilities for a match
 * @param match match structure
 */
int print_vulnerabilities(component_data_t *component)
{
	if (!ldb_table_exists(oss_vulnerability.db, oss_vulnerability.table)) // skip purl if the table is not present
		return 0;
	scanlog("Process vulnerabilities\n");
	uint32_t crclist[CRC_LIST_LEN];
	memset(crclist, 0, sizeof(crclist));

	component_data_t comp = *component;
	clean_versions(&comp);
	component->vulnerabilities_text = NULL;
	component->vulnerabilities = 0;
	component->crclist = crclist;
	int records = 0;
	/* Search for purl */
	for (int i = 0; i < MAX_PURLS && component->purls[i]; i++)
		records += ldb_fetch_recordset(NULL, oss_vulnerability, component->purls_md5[i], false, print_vulnerability_item, component);

	/* Search for purl@version in NVD */

	for (int i = 0; i < MAX_PURLS && component->purls[i]; i++)
	{
		uint8_t md5[MD5_LEN];
		purl_version_md5(md5, component->purls[i], comp.version);
		records += ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, component);
	}

	/* Search for for purl@latest_version in NVD */
	if (strcmp(comp.version, comp.latest_version))
	{
		for (int i = 0; i < MAX_PURLS && component->purls[i]; i++)
		{
			uint8_t md5[MD5_LEN];
			purl_version_md5(md5, component->purls[i], comp.latest_version);
			records += ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, component);
		}
	}

	/* Search for vendor/component/version in NVD */
	uint8_t md5[MD5_LEN];
	version_md5(md5, component->vendor, component->component, comp.version);
	records += ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, component);

	/* Search for vendor/component/latest_version in NVD */
	if (strcmp(comp.version, comp.latest_version))
	{
		uint8_t md5[MD5_LEN];
		version_md5(md5, component->vendor, comp.component, comp.latest_version);
		records += ldb_fetch_recordset(NULL, oss_vulnerability, md5, false, print_vulnerability_item, component);
	}

	char * aux = NULL;
	asprintf(&aux, "\"vulnerabilities\": [%s]", component->vulnerabilities_text ? component->vulnerabilities_text : "");
	free(component->vulnerabilities_text);
	component->vulnerabilities_text = aux;
	component->vulnerabilities = records;
	return records;
}
